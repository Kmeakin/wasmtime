;; `select`/`bitselect`-related rewrites

;; remove select when both choices are the same
(rule (simplify (select    ty _ x x)) x)
(rule (simplify (bitselect ty _ x x)) x)

;; transpose operation on select to select on operation:
;; unop(select(cond, x, y)) => select(cond, unop(x), unop(y))
(rule (simplify (unop op_ty op (select sel_ty cond x y)))
      (select sel_ty cond (unop op_ty op x) (unop op_ty op y)))

;; binop(select(cond, x, y), z) => select(cond, binop(x, z), binop(y, z))
(rule (simplify (binop op_ty op (select sel_ty cond x y) z))
      (select sel_ty cond (binop op_ty op x z) (binop op_ty op y z)))

;; binop(x, select(cond, y, z)) => select(cond, binop(x, y), binop(x, z))
(rule (simplify (binop op_ty op x (select sel_ty cond y z)))
      (select sel_ty cond (binop op_ty op x y) (binop op_ty op x z)))

;; ternop(select(cond, w, x), y, z) => select(cond, ternop(w, y, z), ternop(x, y, z))
(rule (simplify (ternop op_ty op (select sel_ty cond w x) y z))
      (select sel_ty cond (ternop op_ty op w y z) (ternop op_ty op x y z)))

;; ternop(w, select(cond, x, y), z) => select(cond, ternop(w, x, z), ternop(w, y, z))
(rule (simplify (ternop op_ty op w (select sel_ty cond x y) z))
      (select sel_ty cond (ternop op_ty op w x z) (ternop op_ty op w y z)))

;; ternop(w, x, select(cond, y, z)) => select(cond, ternop(w, x, y), ternop(w, x, z))
(rule (simplify (ternop op_ty op w x (select sel_ty cond y z)))
      (select sel_ty cond (ternop op_ty op w x y) (ternop op_ty op w x z)))

;; icmp(cc, select(cond, x, y), z) => select(cond, icmp(cc, x, z), icmp(cc, y, z))
(rule (simplify (icmp cmp_ty cc (select sel_ty cond x y) z))
      (select sel_ty cond (icmp cmp_ty cc x z) (icmp cmp_ty cc y z)))

;; icmp(cc, x, select(cond, y, z)) => select(cond, icmp(cc, x, y), icmp(cc, x, z))
(rule (simplify (icmp cmp_ty cc x (select sel_ty cond y z)))
      (select sel_ty cond (icmp cmp_ty cc x y) (icmp cmp_ty cc x z)))

;; fcmp(cc, select(cond, x, y), z) => select(cond, fcmp(cc, x, z), fcmp(cc, y, z))
(rule (simplify (fcmp cmp_ty cc (select sel_ty cond x y) z))
      (select sel_ty cond (fcmp cmp_ty cc x z) (fcmp cmp_ty cc y z)))

;; fcmp(cc, x, select(cond, y, z)) => select(cond, fcmp(cc, x, y), fcmp(cc, x, z))
(rule (simplify (fcmp cmp_ty cc x (select sel_ty cond y z)))
      (select sel_ty cond (fcmp cmp_ty cc x y) (fcmp cmp_ty cc x z)))

;; Transform select-of-icmp into {u,s}{min,max} instructions where possible.
(rule (simplify (select ty (sgt _ x y) x y)) (smax ty x y))
(rule (simplify (select ty (sge _ x y) x y)) (smax ty x y))
(rule (simplify (select ty (ugt _ x y) x y)) (umax ty x y))
(rule (simplify (select ty (uge _ x y) x y)) (umax ty x y))
(rule (simplify (select ty (slt _ x y) x y)) (smin ty x y))
(rule (simplify (select ty (sle _ x y) x y)) (smin ty x y))
(rule (simplify (select ty (ult _ x y) x y)) (umin ty x y))
(rule (simplify (select ty (ule _ x y) x y)) (umin ty x y))

;; These are the same rules as above, but when the operands for select are swapped
(rule (simplify (select ty (slt _ x y) y x)) (smax ty x y))
(rule (simplify (select ty (sle _ x y) y x)) (smax ty x y))
(rule (simplify (select ty (ult _ x y) y x)) (umax ty x y))
(rule (simplify (select ty (ule _ x y) y x)) (umax ty x y))
(rule (simplify (select ty (sgt _ x y) y x)) (smin ty x y))
(rule (simplify (select ty (sge _ x y) y x)) (smin ty x y))
(rule (simplify (select ty (ugt _ x y) y x)) (umin ty x y))
(rule (simplify (select ty (uge _ x y) y x)) (umin ty x y))

;; Transform bitselect-of-icmp into {u,s}{min,max} instructions where possible.
(rule (simplify (bitselect ty @ (multi_lane _ _) (sgt _ x y) x y)) (smax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sge _ x y) x y)) (smax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ugt _ x y) x y)) (umax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (uge _ x y) x y)) (umax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (slt _ x y) x y)) (smin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sle _ x y) x y)) (smin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ult _ x y) x y)) (umin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ule _ x y) x y)) (umin ty x y))

;; These are the same rules as above, but when the operands for select are swapped
(rule (simplify (bitselect ty @ (multi_lane _ _) (slt _ x y) y x)) (smax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sle _ x y) y x)) (smax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ult _ x y) y x)) (umax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ule _ x y) y x)) (umax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sgt _ x y) y x)) (smin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sge _ x y) y x)) (smin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ugt _ x y) y x)) (umin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (uge _ x y) y x)) (umin ty x y))

;; For floats convert fcmp lt into pseudo_min and gt into pseudo_max
;;
;; fmax_pseudo docs state:
;; The behaviour for this operations is defined as  fmax_pseudo(a, b) = (a < b) ? b : a, and the behaviour for zero
;; or NaN inputs follows from the behaviour of < with such inputs.
;;
;; That is exactly the operation that we match here!
(rule (simplify
       (select ty (fcmp _ (FloatCC.LessThan) x y) x y))
      (fmin_pseudo ty x y))
(rule (simplify
       (select ty (fcmp _ (FloatCC.GreaterThan) x y) x y))
      (fmax_pseudo ty x y))

;; TODO: perform this same optimization to `f{min,max}_pseudo` for vectors
;; with the `bitselect` instruction, but the pattern is a bit more complicated
;; due to most bitselects-over-floats having bitcasts.
